"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.decrypt = exports.encrypt = void 0;
const crypto_js_1 = __importDefault(require("crypto-js"));
/**
 * Encrypts the provided data using the specified parameters.
 * @param data - The data to encrypt.
 * @param key - The encryption key.
 * @param iv - The initialization vector.
 * @param encryptionType - The type of encryption (base64 or hex).
 * @returns The encrypted payload.
 * @throws Error if validation fails.
 */
function encrypt(data, key, iv, encryptionType) {
    // Validate parameters
    if (typeof key !== "string" || !key) {
        throw new Error("Encryption key must be a non-empty string.");
    }
    if (typeof iv !== "string" || !iv) {
        throw new Error("Initialization vector must be a non-empty string.");
    }
    if (!["base64", "hex"].includes(encryptionType)) {
        throw new Error("Invalid encryption type.");
    }
    try {
        // Convert data to a string
        const dataToEncrypt = JSON.stringify(data);
        const encryptionKey = crypto_js_1.default.enc.Utf8.parse(key);
        const initializationVector = crypto_js_1.default.enc.Utf8.parse(iv);
        // Encrypt the data
        const encryptedData = crypto_js_1.default.AES.encrypt(dataToEncrypt, encryptionKey, { iv: initializationVector }).toString();
        // Convert encrypted data to the specified encryption type
        let encryptedPayload;
        if (encryptionType === "base64") {
            encryptedPayload = encryptedData;
        }
        else {
            encryptedPayload = crypto_js_1.default.enc.Hex.stringify(crypto_js_1.default.enc.Base64.parse(encryptedData));
        }
        return { payload: encryptedPayload };
    }
    catch (error) {
        // Return error message if encryption fails
        throw new Error(`Encryption failed: ${error.message}`);
    }
}
exports.encrypt = encrypt;
/**
 * Decrypts the provided encrypted data using the specified parameters.
 * @param encryptedData - The encrypted payload.
 * @param key - The encryption key.
 * @param iv - The initialization vector.
 * @param encryptionType - The type of encryption (base64 or hex).
 * @returns The decrypted data.
 * @throws Error if validation fails or decryption fails.
 */
function decrypt(encryptedData, key, iv, encryptionType) {
    // Validate parameters
    if (typeof key !== "string" || !key) {
        throw new Error("Encryption key must be a non-empty string.");
    }
    if (typeof iv !== "string" || !iv) {
        throw new Error("Initialization vector must be a non-empty string.");
    }
    if (!["base64", "hex"].includes(encryptionType)) {
        throw new Error("Invalid encryption type.");
    }
    try {
        // Convert key and IV to CryptoJS format
        const encryptionKey = crypto_js_1.default.enc.Utf8.parse(key);
        const initializationVector = crypto_js_1.default.enc.Utf8.parse(iv);
        // Convert encrypted payload to CryptoJS format
        let encryptedDataBytes;
        if (encryptionType === "base64") {
            encryptedDataBytes = crypto_js_1.default.enc.Base64.parse(encryptedData.payload);
        }
        else {
            encryptedDataBytes = crypto_js_1.default.enc.Hex.parse(encryptedData.payload);
        }
        // Decrypt the data
        const decryptedData = crypto_js_1.default.AES.decrypt(crypto_js_1.default.enc.Base64.stringify(encryptedDataBytes), encryptionKey, { iv: initializationVector }).toString(crypto_js_1.default.enc.Utf8);
        return JSON.parse(decryptedData);
    }
    catch (error) {
        // Return error message if decryption fails
        throw new Error(`Decryption failed: ${error.message}`);
    }
}
exports.decrypt = decrypt;
